# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1az9rbFwqphO6aDAhL0OhFleAJdR5ciJS
"""

# -*- coding: utf-8 -*-
# =============================================================================
# App Streamlit ‚Äî Pipeline sin fugas (EDA + preparaci√≥n)
# Carga desde UCI (ucimlrepo), limpieza segura, binarizaci√≥n de y y EDA visual.
# =============================================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import streamlit as st

from ucimlrepo import fetch_ucirepo
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

from collections import Counter

# -------------------------------
# Configuraci√≥n de la p√°gina
# -------------------------------
st.set_page_config(
    page_title="Diabetes ‚Äî EDA y Preparaci√≥n (Sin Fugas)",
    page_icon="ü©∫",
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("ü©∫ An√°lisis de Diabetes ‚Äî EDA y Preparaci√≥n (Sin Fugas)")
st.caption("Carga directa desde UCI, limpieza b√°sica segura, binarizaci√≥n de y (= 'NO' vs 'SI'), EDA y split temprano.")

# -------------------------------
# Par√°metros
# -------------------------------
with st.sidebar:
    st.header("‚öôÔ∏è Par√°metros")
    RANDOM_STATE = st.number_input("Random state", min_value=0, value=42, step=1)
    N_SAMPLE = st.number_input("Muestreo opcional (0 = sin muestreo)", min_value=0, value=5000, step=500,
                               help="Si el dataset es muy grande, toma una muestra aleatoria para pruebas.")
    show_raw_preview = st.checkbox("Ver muestra de datos crudos", value=False)
    show_numeric_hists = st.checkbox("Graficar histogramas num√©ricos", value=True)
    limit_cats = st.number_input("M√°x. categor√≠as a graficar por variable", min_value=5, value=30, step=5)
    st.divider()
    st.markdown("**Nota:** Todo el aprendizaje debe ir dentro de CV; aqu√≠ solo hacemos limpieza segura + EDA + split temprano.")

# -------------------------------
# 1) Cargar datos (X, y)
# -------------------------------
@st.cache_data(show_spinner=True)
def load_data(id_ucirepo: int = 296):
    ds = fetch_ucirepo(id=id_ucirepo)  # Diabetes 130-US hospitals (UCI id=296)
    X = ds.data.features.copy()
    y = ds.data.targets.copy().iloc[:, 0].astype(str)
    return X, y

X, y = load_data()

st.subheader("üì• Carga de datos")
st.write(f"**Formas:** X = `{X.shape}` | y = `{y.shape}`")
if show_raw_preview:
    st.write("**Vista previa (X):**")
    st.dataframe(X.head(), use_container_width=True)
    st.write("**Vista previa (y):**")
    st.write(y.head())

# -------------------------------
# EDA: an√°lisis de categ√≥ricas y faltantes (antes de limpiar)
# -------------------------------
st.subheader("üîé EDA ‚Äî Variables categ√≥ricas y valores faltantes")
cat_cols_eda = X.select_dtypes(exclude=np.number).columns.tolist()

with st.expander("N√∫mero de clases √∫nicas por variable categ√≥rica"):
    if cat_cols_eda:
        nunique_info = {col: int(X[col].nunique()) for col in cat_cols_eda}
        nunique_df = pd.DataFrame.from_dict(nunique_info, orient="index", columns=["Clases √∫nicas"]).sort_values("Clases √∫nicas", ascending=False)
        st.dataframe(nunique_df, use_container_width=True)
    else:
        st.info("No se detectaron variables categ√≥ricas en X.")

missing_data = X.isnull().sum()
missing_data = missing_data[missing_data > 0].sort_values(ascending=False)

with st.expander("Valores faltantes por columna"):
    if not missing_data.empty:
        total_rows = len(X)
        missing_pct = (missing_data / total_rows) * 100
        missing_table = pd.DataFrame({
            "Cantidad Faltante": missing_data,
            "Porcentaje (%)": missing_pct.round(3)
        })
        st.dataframe(missing_table, use_container_width=True)

        total_missing_cells = missing_data.sum()
        missing_pct_total = (missing_data / total_missing_cells) * 100
        missing_table_total = pd.DataFrame({
            "Cantidad Faltante": missing_data,
            "Porcentaje del Total Faltante (%)": missing_pct_total.round(3)
        })
        st.write("**Distribuci√≥n del total de faltantes por columna:**")
        st.dataframe(missing_table_total, use_container_width=True)
    else:
        st.success("No hay valores faltantes en X.")

# -------------------------------
# Limpieza segura: quitar IDs, c√≥digos y variables de alta fuga
# -------------------------------
st.subheader("üßπ Limpieza (solo lo 'seguro')")

default_drop = [
    "encounter_id","patient_nbr","encounterid","patientnbr",
    "diag_1","diag_2","diag_3","payer_code","medical_specialty",
    "weight","max_glu_serum","A1Cresult"
]
drop_candidates = [c for c in default_drop if c in X.columns]
to_drop = st.multiselect(
    "Columnas a eliminar por posibles fugas/alta cardinalidad:",
    options=sorted(X.columns.tolist()),
    default=drop_candidates
)

X = X.drop(columns=to_drop, errors="ignore")
st.write(f"**X (post limpieza segura):** `{X.shape}`")

# -------------------------------
# Muestreo opcional para acelerar
# -------------------------------
if N_SAMPLE and len(X) > N_SAMPLE:
    st.info(f"Aplicando muestreo aleatorio sin reemplazo de **{N_SAMPLE}** filas (de {len(X)}).")
    rng = np.random.RandomState(RANDOM_STATE)
    idx = rng.choice(X.index, size=N_SAMPLE, replace=False)
    X = X.loc[idx].reset_index(drop=True)
    y = y.loc[idx].reset_index(drop=True)

# -------------------------------
# Tipos de columna
# -------------------------------
num_cols = X.select_dtypes(include=np.number).columns.tolist()
cat_cols = X.select_dtypes(exclude=np.number).columns.tolist()

col1, col2 = st.columns(2)
with col1:
    st.metric("Variables num√©ricas", len(num_cols))